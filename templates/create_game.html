{% extends "base.html" %}

{% block title %}Create Game - GlitchPeachAI{% endblock %}

{% block content %}
<main>
  <section class="hero">
    <div class="kicker"><span class="dot"></span>CREATE ‚Ä¢ PREVIEW ‚Ä¢ PUBLISH</div>
    <h1>AI GAME GENERATOR</h1>
    <p class="sub">Describe your game idea and watch AI bring it to life</p>
    <div class="credits-display">
      <span class="credits-icon">ü™ô</span>
      <span class="credits-text">Balance: <strong>{{ user_credits }}</strong> Credits</span>
    </div>
  </section>

  <section class="section">
    <div class="game-creator-container">
      <!-- Game Preview Panel -->
      <div class="preview-panel">
        <div class="preview-header">
          <h2>GAME PREVIEW</h2>
          <div class="preview-controls">
            <button id="fullscreen-btn" class="btn btn-ghost" style="display: none;" onclick="toggleFullscreen()">
              <span>‚õ∂ FULLSCREEN</span>
            </button>
            <button id="publish-btn" class="btn btn-cta" style="display: none;" onclick="publishGame()">
              <span>üöÄ PUBLISH GAME</span>
            </button>
          </div>
        </div>
        
        <div class="preview-screen" id="preview-screen">
          <div class="preview-placeholder">
            <div class="placeholder-content">
              <div class="placeholder-icon">üéÆ</div>
              <h3>Your game will appear here</h3>
              <p>Enter a game idea below and click "Generate" to create your game</p>
            </div>
          </div>
          
          <!-- Progress Screen (hidden by default) -->
          <div class="progress-screen" id="progress-screen" style="display: none;">
            <div class="progress-content">
              <div class="progress-header">
                <p>Creating your personalized game experience...</p>
              </div>
              
              <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar">
                  <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-percentage" id="progress-percentage">0%</div>
              </div>
              
              <div class="progress-stages">
                <div class="stage" data-stage="0">
                  <span class="stage-icon">‚è≥</span>
                  <span class="stage-text">Generating terrain...</span>
                  <span class="stage-check">‚úÖ</span>
                </div>
                <div class="stage" data-stage="1">
                  <span class="stage-icon">‚è≥</span>
                  <span class="stage-text">Building the world...</span>
                  <span class="stage-check">‚úÖ</span>
                </div>
                <div class="stage" data-stage="2">
                  <span class="stage-icon">‚è≥</span>
                  <span class="stage-text">Placing objects...</span>
                  <span class="stage-check">‚úÖ</span>
                </div>
                <div class="stage" data-stage="3">
                  <span class="stage-icon">‚è≥</span>
                  <span class="stage-text">Spawning characters...</span>
                  <span class="stage-check">‚úÖ</span>
                </div>
                <div class="stage" data-stage="4">
                  <span class="stage-icon">‚è≥</span>
                  <span class="stage-text">Adding interactions...</span>
                  <span class="stage-check">‚úÖ</span>
                </div>
                <div class="stage" data-stage="5">
                  <span class="stage-icon">‚è≥</span>
                  <span class="stage-text">Balancing gameplay...</span>
                  <span class="stage-check">‚úÖ</span>
                </div>
                <div class="stage" data-stage="6">
                  <span class="stage-icon">‚è≥</span>
                  <span class="stage-text">Creating challenges...</span>
                  <span class="stage-check">‚úÖ</span>
                </div>
                <div class="stage" data-stage="7">
                  <span class="stage-icon">‚è≥</span>
                  <span class="stage-text">Polishing details...</span>
                  <span class="stage-check">‚úÖ</span>
                </div>
                <div class="stage" data-stage="8">
                  <span class="stage-icon">‚è≥</span>
                  <span class="stage-text">Running final checks...</span>
                  <span class="stage-check">‚úÖ</span>
                </div>
                <div class="stage" data-stage="9">
                  <span class="stage-icon">‚è≥</span>
                  <span class="stage-text">Almost ready... üéÆ</span>
                  <span class="stage-check">‚úÖ</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Prompt Interface Panel -->
      <div class="prompt-panel">
        <div class="prompt-header">
          <h3>GAME GENERATOR</h3>
        </div>
        
        <div class="prompt-form">
          <div class="form-group">
            <label class="form-label" for="game-prompt">DESCRIBE YOUR GAME IDEA</label>
            <textarea 
              class="form-input prompt-textarea" 
              id="game-prompt" 
              name="prompt" 
              rows="4" 
              placeholder="e.g., Create a space shooter game where the player controls a spaceship and shoots asteroids. Add power-ups and increasing difficulty levels."
            ></textarea>
          </div>

          <div class="form-group">
            <label class="form-label" for="model-select">AI MODEL</label>
            <select class="form-input" id="model-select" name="model">
              <option value="QP">Quick Prototype</option>
              <option value="PG">Polished Game</option>
              <option value="PE">Premium Experience</option>
            </select>
            <div class="model-description" style="font-size: 9px; color: var(--muted); margin-top: 4px; line-height: 1.4;">
              <div id="model-desc-QP" style="display: none;">For testing game ideas, fast drafts. Cost: {{ model_prices.QP }} credit{% if model_prices.QP != 1 %}s{% endif %}.</div>
              <div id="model-desc-PG" style="display: none;">Better balance, assets, replay value. Cost: {{ model_prices.PG }} credit{% if model_prices.PG != 1 %}s{% endif %}.</div>
              <div id="model-desc-PE" style="display: none;">Top-tier AI creativity, ready-to-share games. Cost: {{ model_prices.PE }} credit{% if model_prices.PE != 1 %}s{% endif %}.</div>
            </div>
            <div class="model-cost" id="model-cost" style="font-size: 10px; color: var(--cyber); margin-top: 6px; font-weight: 600;">
              Cost: <span id="cost-amount">{{ model_prices.PE }}</span> credit{% if model_prices.PE != 1 %}s{% endif %}
            </div>
          </div>

          <div class="form-actions">
            <button id="generate-btn" class="btn btn-cta" onclick="generateGame()">
              <span id="generate-text">‚ú® GENERATE GAME</span>
              <div id="generate-progress" class="btn-progress" style="display: none;">
                <div class="btn-progress-fill" id="btn-progress-fill"></div>
                <span class="btn-progress-text">GENERATING...</span>
              </div>
            </button>
            <div class="refine-container" style="display: none;">
              <button id="refine-btn" class="btn btn-ghost" onclick="refineGame()">
                <span id="refine-text">üîß REFINE GAME</span>
                <div id="refine-progress" class="btn-progress" style="display: none;">
                  <div class="btn-progress-fill" id="refine-progress-fill"></div>
                  <span class="btn-progress-text">üîß REFINE GAME</span>
                </div>
              </button>
              <div class="refine-progress-bar" id="refine-progress-bar" style="display: none;">
                <div class="refine-progress-fill" id="refine-progress-fill-bar"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Game Info Panel (appears after generation) -->
        <div id="game-info" class="game-info" style="display: none;">
          <div class="game-title-section">
            <label class="form-label" for="game-title-input">GAME TITLE</label>
            <input class="form-input" type="text" id="game-title-input" placeholder="Enter game title...">
          </div>
          
          <div class="game-stats">
            <div class="stat-item">
              <span class="stat-label">STATUS:</span>
              <span class="stat-value" id="game-status">DRAFT</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">CREATED:</span>
              <span class="stat-value" id="game-created">NOW</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
</main>

<!-- Game Publishing Modal -->
<div id="publish-modal" class="modal" style="display: none;">
  <div class="modal-content">
    <div class="modal-header">
      <h2>PUBLISH GAME</h2>
      <button class="modal-close" onclick="closePublishModal()">&times;</button>
    </div>
    <div class="modal-body">
      <form id="publish-form">
        <div class="form-group">
          <label class="form-label" for="publish-title">GAME TITLE</label>
          <input class="form-input" type="text" id="publish-title" name="title" required placeholder="Enter game title">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="publish-description">DESCRIPTION</label>
          <textarea class="form-input" id="publish-description" name="description" rows="3" required placeholder="Describe your game..."></textarea>
        </div>
        
        <div class="modal-actions">
          <button type="button" class="btn btn-ghost" onclick="closePublishModal()" id="publish-cancel-btn" style="display: inline-flex; visibility: visible; opacity: 1; color: #e6e6ea !important; font-size: 13px;">
            <span style="color: #e6e6ea !important; position: relative; z-index: 100;">CANCEL</span>
          </button>
          <button type="submit" class="btn btn-cta" id="publish-submit-btn" style="display: inline-flex; visibility: visible; opacity: 1; color: #e6e6ea !important; font-size: 13px; position: relative;">
            <span id="publish-text" style="color: #e6e6ea !important; position: relative; z-index: 100;">üöÄ PUBLISH TO COMMUNITY</span>
            <div id="publish-progress" class="btn-progress" style="display: none;">
              <div class="btn-progress-fill" id="publish-progress-fill"></div>
              <span class="btn-progress-text">PUBLISHING...</span>
            </div>
          </button>
        </div>
      </form>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Global variables
let currentGameHtml = '';
let currentGameTitle = '';
let isGenerating = false;
let progressInterval = null;
let progressStartTime = null;
let gameGenerationComplete = false;

// Model pricing data from server
const modelPrices = {
  'QP': {{ model_prices.QP }},
  'PG': {{ model_prices.PG }},
  'PE': {{ model_prices.PE }}
};

document.addEventListener('DOMContentLoaded', function() {
  // Initialize the interface
  const promptTextarea = document.getElementById('game-prompt');
  const generateBtn = document.getElementById('generate-btn');
  
  // Auto-resize textarea
  promptTextarea.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = (this.scrollHeight) + 'px';
  });
  
  // Enable generate button when there's text and enough credits
  promptTextarea.addEventListener('input', function() {
    const hasText = this.value.trim().length > 0;
    const selectedModel = document.getElementById('model-select').value;
    const requiredCredits = modelPrices[selectedModel];
    const currentCredits = parseInt(document.querySelector('.credits-text strong').textContent);
    const hasEnoughCredits = currentCredits >= requiredCredits;
    
    generateBtn.disabled = !hasText || !hasEnoughCredits;
  });
  
  // Model selection description and cost handler
  const modelSelect = document.getElementById('model-select');
  const costAmount = document.getElementById('cost-amount');
  const modelCost = document.getElementById('model-cost');
  
  modelSelect.addEventListener('change', function() {
    const selectedModel = this.value;
    const cost = modelPrices[selectedModel];
    
    // Hide all descriptions
    document.querySelectorAll('[id^="model-desc-"]').forEach(desc => {
      desc.style.display = 'none';
    });
    
    // Show selected model description
    const descId = `model-desc-${selectedModel}`;
    const descElement = document.getElementById(descId);
    if (descElement) {
      descElement.style.display = 'block';
    }
    
    // Update cost display
    if (costAmount) {
      costAmount.textContent = cost;
    }
    
    // Update cost text (singular/plural)
    if (modelCost) {
      const creditText = cost === 1 ? 'credit' : 'credits';
      modelCost.innerHTML = `Cost: <span id="cost-amount">${cost}</span> ${creditText}`;
    }
    
    // Check if user has enough credits for this model
    checkCreditsAvailability();
  });
  
  // Initialize with first model description
  modelSelect.dispatchEvent(new Event('change'));
  
  // Initialize button state
  generateBtn.disabled = true;
  
  // Check credits availability on page load
  checkCreditsAvailability();
});

function checkCreditsAvailability() {
  const selectedModel = document.getElementById('model-select').value;
  const requiredCredits = modelPrices[selectedModel];
  const currentCredits = parseInt(document.querySelector('.credits-text strong').textContent);
  const generateBtn = document.getElementById('generate-btn');
  const modelCost = document.getElementById('model-cost');
  
  if (currentCredits < requiredCredits) {
    // Disable generate button and show insufficient credits warning
    generateBtn.disabled = true;
    generateBtn.style.opacity = '0.5';
    generateBtn.style.cursor = 'not-allowed';
    
    // Update cost display to show insufficient credits
    if (modelCost) {
      modelCost.style.color = '#ff6b6b';
      modelCost.style.borderColor = '#ff6b6b';
      modelCost.style.backgroundColor = 'rgba(255, 107, 107, 0.1)';
      modelCost.innerHTML = `Cost: <span id="cost-amount">${requiredCredits}</span> credit${requiredCredits !== 1 ? 's' : ''} <span style="color: #ff6b6b;">(Insufficient credits!)</span>`;
    }
  } else {
    // Enable generate button and show normal cost
    generateBtn.disabled = false;
    generateBtn.style.opacity = '1';
    generateBtn.style.cursor = 'pointer';
    
    // Update cost display to show normal state
    if (modelCost) {
      modelCost.style.color = 'var(--cyber)';
      modelCost.style.borderColor = 'var(--cyber)';
      modelCost.style.backgroundColor = 'rgba(0, 255, 255, 0.1)';
      modelCost.innerHTML = `Cost: <span id="cost-amount">${requiredCredits}</span> credit${requiredCredits !== 1 ? 's' : ''}`;
    }
  }
}

async function generateGame() {
  if (isGenerating) return;
  
  const prompt = document.getElementById('game-prompt').value.trim();
  const model = document.getElementById('model-select').value;
  
  if (!prompt) {
    App.showAlert('Please enter a game idea first.', 'error');
    return;
  }
  
  // Check if user has enough credits before starting animation
  const requiredCredits = modelPrices[model];
  const currentCredits = parseInt(document.querySelector('.credits-text strong').textContent);
  
  if (currentCredits < requiredCredits) {
    App.showAlert(`Insufficient credits! You need ${requiredCredits} credits but only have ${currentCredits}.`, 'error');
    return;
  }
  
  isGenerating = true;
  gameGenerationComplete = false;
  setGeneratingState(true);
  showProgressScreen();
  startProgressAnimation();
  
  try {
    const response = await fetch('/api/generate-game', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ prompt: prompt, model: model })
    });
    
    const data = await response.json();
    
    if (data.success) {
      gameGenerationComplete = true;
      currentGameHtml = data.html;
      currentGameTitle = data.title;
      
      // Complete progress quickly if not already done
      completeProgress();
      
      // Update credits display if provided
      if (data.remaining_credits !== undefined) {
        updateCreditsDisplay(data.remaining_credits);
      }
      
      // Wait a brief moment to show completion, then display game
      setTimeout(() => {
        hideProgressScreen();
        displayGamePreview(data.html);
        showGameInfo(data.title);
        showGameControls();
        App.showAlert(`Game generated successfully! Used ${data.credits_deducted || 0} credits.`, 'success');
      }, 1000);
    } else {
      gameGenerationComplete = true;
      completeProgress();
      setTimeout(() => {
        hideProgressScreen();
        
        // Handle insufficient credits specifically
        if (data.error_type === 'insufficient_credits') {
          App.showAlert(`Insufficient credits! You need ${data.required_credits} credits but only have ${data.current_credits}.`, 'error');
        } else {
          App.showAlert(data.error || 'Failed to generate game. Please try again.', 'error');
        }
      }, 500);
    }
  } catch (error) {
    console.error('Generation error:', error);
    gameGenerationComplete = true;
    completeProgress();
    setTimeout(() => {
      hideProgressScreen();
      App.showAlert('Failed to generate game. Please check your connection and try again.', 'error');
    }, 500);
  } finally {
    isGenerating = false;
    setGeneratingState(false);
  }
}

async function refineGame() {
  if (isGenerating || !currentGameHtml) return;
  
  const prompt = document.getElementById('game-prompt').value.trim();
  const model = document.getElementById('model-select').value;
  
  if (!prompt) {
    App.showAlert('Please enter refinement instructions.', 'error');
    return;
  }
  
  // Check if user has enough credits before starting animation
  const requiredCredits = modelPrices[model];
  const currentCredits = parseInt(document.querySelector('.credits-text strong').textContent);
  
  if (currentCredits < requiredCredits) {
    App.showAlert(`Insufficient credits! You need ${requiredCredits} credits but only have ${currentCredits}.`, 'error');
    return;
  }
  
  isGenerating = true;
  setRefiningState(true);
  startRefineProgress();
  
  try {
    const response = await fetch('/api/refine-game', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ 
        instruction: prompt,
        current_html: currentGameHtml,
        model: model
      })
    });
    
    const data = await response.json();
    
    if (data.success) {
      currentGameHtml = data.html;
      
      // Complete refine progress
      completeRefineProgress();
      
      // Update credits display if provided
      if (data.remaining_credits !== undefined) {
        updateCreditsDisplay(data.remaining_credits);
      }
      
      // Wait a moment then update UI
      setTimeout(() => {
        displayGamePreview(data.html);
        document.getElementById('game-prompt').value = '';
        document.getElementById('game-prompt').style.height = 'auto';
        App.showAlert(`Game refined successfully! Used ${data.credits_deducted || 0} credits.`, 'success');
      }, 800);
    } else {
      completeRefineProgress();
      setTimeout(() => {
        // Handle insufficient credits specifically
        if (data.error_type === 'insufficient_credits') {
          App.showAlert(`Insufficient credits! You need ${data.required_credits} credits but only have ${data.current_credits}.`, 'error');
        } else {
          App.showAlert(data.error || 'Failed to refine game. Please try again.', 'error');
        }
      }, 500);
    }
  } catch (error) {
    console.error('Refinement error:', error);
    completeRefineProgress();
    setTimeout(() => {
      App.showAlert('Failed to refine game. Please check your connection and try again.', 'error');
    }, 500);
  } finally {
    isGenerating = false;
    setRefiningState(false);
  }
}

function displayGamePreview(html) {
  const previewScreen = document.getElementById('preview-screen');
  
  // Create iframe for game preview
  const iframe = document.createElement('iframe');
  iframe.style.width = '100%';
  iframe.style.height = '100%';
  iframe.style.border = 'none';
  iframe.style.borderRadius = '8px';
  iframe.srcdoc = html;
  
  // Clear previous content and add iframe
  previewScreen.innerHTML = '';
  previewScreen.appendChild(iframe);
}

function updateCreditsDisplay(newCredits) {
  const creditsText = document.querySelector('.credits-text strong');
  if (creditsText) {
    creditsText.textContent = newCredits;
  }
  
  // Recheck credits availability after update
  checkCreditsAvailability();
}

function showGameInfo(title) {
  const gameInfo = document.getElementById('game-info');
  const titleInput = document.getElementById('game-title-input');
  const createdSpan = document.getElementById('game-created');
  
  titleInput.value = title;
  createdSpan.textContent = new Date().toLocaleString();
  gameInfo.style.display = 'block';
}

function showGameControls() {
  document.getElementById('fullscreen-btn').style.display = 'inline-block';
  document.getElementById('publish-btn').style.display = 'inline-block';
  document.querySelector('.refine-container').style.display = 'block';
}

function setGeneratingState(generating) {
  const generateBtn = document.getElementById('generate-btn');
  const generateText = document.getElementById('generate-text');
  const generateProgress = document.getElementById('generate-progress');
  const promptTextarea = document.getElementById('game-prompt');
  
  if (generating) {
    generateText.style.display = 'none';
    generateProgress.style.display = 'flex';
    generateBtn.disabled = true;
    promptTextarea.disabled = true;
  } else {
    generateText.style.display = 'inline';
    generateProgress.style.display = 'none';
    generateBtn.disabled = false;
    promptTextarea.disabled = false;
    // Reset button progress bar
    const btnProgressFill = document.getElementById('btn-progress-fill');
    if (btnProgressFill) {
      btnProgressFill.style.width = '0%';
    }
  }
}

function setRefiningState(refining) {
  const refineBtn = document.getElementById('refine-btn');
  const refineText = document.getElementById('refine-text');
  const refineProgress = document.getElementById('refine-progress');
  const refineProgressBar = document.getElementById('refine-progress-bar');
  const promptTextarea = document.getElementById('game-prompt');
  
  if (refining) {
    refineText.style.display = 'none';
    refineProgress.style.display = 'flex';
    refineProgressBar.style.display = 'block';
    refineBtn.disabled = true;
    promptTextarea.disabled = true;
  } else {
    refineText.style.display = 'inline';
    refineProgress.style.display = 'none';
    refineProgressBar.style.display = 'none';
    refineBtn.disabled = false;
    promptTextarea.disabled = false;
    // Reset progress bars
    const refineProgressFill = document.getElementById('refine-progress-fill');
    const refineProgressFillBar = document.getElementById('refine-progress-fill-bar');
    if (refineProgressFill) refineProgressFill.style.width = '0%';
    if (refineProgressFillBar) refineProgressFillBar.style.width = '0%';
  }
}

// Progress Screen Functions
function showProgressScreen() {
  const progressScreen = document.getElementById('progress-screen');
  const placeholder = document.querySelector('.preview-placeholder');
  
  if (placeholder) placeholder.style.display = 'none';
  if (progressScreen) progressScreen.style.display = 'flex';
  
  // Reset progress elements
  resetProgress();
}

function hideProgressScreen() {
  const progressScreen = document.getElementById('progress-screen');
  const placeholder = document.querySelector('.preview-placeholder');
  
  if (progressScreen) progressScreen.style.display = 'none';
  if (placeholder) placeholder.style.display = 'flex';
  
  // Clear progress interval
  if (progressInterval) {
    clearInterval(progressInterval);
    progressInterval = null;
  }
}

function resetProgress() {
  const progressFill = document.getElementById('progress-fill');
  const progressPercentage = document.getElementById('progress-percentage');
  const btnProgressFill = document.getElementById('btn-progress-fill');
  const stages = document.querySelectorAll('.stage');
  
  if (progressFill) progressFill.style.width = '0%';
  if (progressPercentage) progressPercentage.textContent = '0%';
  if (btnProgressFill) btnProgressFill.style.width = '0%';
  
  // Reset all stages
  stages.forEach(stage => {
    stage.classList.remove('active', 'completed');
  });
}

function startProgressAnimation() {
  progressStartTime = Date.now();
  const totalDuration = 180000; // 3 minutes in milliseconds
  const stages = document.querySelectorAll('.stage');
  const stageCount = stages.length;
  
  // Clear any existing interval
  if (progressInterval) {
    clearInterval(progressInterval);
  }
  
  progressInterval = setInterval(() => {
    if (gameGenerationComplete) {
      return; // Let completeProgress handle the completion
    }
    
    const elapsed = Date.now() - progressStartTime;
    const progress = Math.min(elapsed / totalDuration, 0.95); // Cap at 95% until completion
    const percentage = Math.floor(progress * 100);
    
    updateProgressDisplay(percentage);
    updateButtonProgress(percentage);
    updateStages(progress, stageCount);
    
    // If we've reached 95% and still no response, slow down the progress
    if (progress >= 0.95) {
      clearInterval(progressInterval);
      // Start a slower interval for the final 5%
      const slowInterval = setInterval(() => {
        if (gameGenerationComplete) {
          clearInterval(slowInterval);
          return;
        }
        const currentPercentage = parseInt(document.getElementById('progress-percentage').textContent);
        if (currentPercentage < 99) {
          const newPercentage = currentPercentage + 1;
          updateProgressDisplay(newPercentage);
          updateButtonProgress(newPercentage);
        }
      }, 5000); // Add 1% every 5 seconds
    }
  }, 200); // Update every 200ms for smooth animation
}

function updateProgressDisplay(percentage) {
  const progressFill = document.getElementById('progress-fill');
  const progressPercentage = document.getElementById('progress-percentage');
  
  if (progressFill) progressFill.style.width = percentage + '%';
  if (progressPercentage) progressPercentage.textContent = percentage + '%';
}

function updateButtonProgress(percentage) {
  const btnProgressFill = document.getElementById('btn-progress-fill');
  if (btnProgressFill) btnProgressFill.style.width = percentage + '%';
}

function updateStages(progress, stageCount) {
  const stages = document.querySelectorAll('.stage');
  const currentStageIndex = Math.floor(progress * stageCount);
  
  stages.forEach((stage, index) => {
    if (index < currentStageIndex) {
      stage.classList.remove('active');
      stage.classList.add('completed');
    } else if (index === currentStageIndex) {
      stage.classList.add('active');
      stage.classList.remove('completed');
    } else {
      stage.classList.remove('active', 'completed');
    }
  });
}

function completeProgress() {
  // Clear any existing interval
  if (progressInterval) {
    clearInterval(progressInterval);
    progressInterval = null;
  }
  
  const stages = document.querySelectorAll('.stage');
  
  // Quickly complete all remaining progress
  const completion = setInterval(() => {
    const currentPercentage = parseInt(document.getElementById('progress-percentage').textContent) || 0;
    
    if (currentPercentage >= 100) {
      clearInterval(completion);
      // Mark all stages as completed
      stages.forEach(stage => {
        stage.classList.remove('active');
        stage.classList.add('completed');
      });
      return;
    }
    
    const newPercentage = Math.min(currentPercentage + 10, 100);
    updateProgressDisplay(newPercentage);
    updateButtonProgress(newPercentage);
    updateStages(newPercentage / 100, stages.length);
  }, 100); // Fast completion
}

// Refine Progress Functions
let refineProgressInterval = null;
let refineComplete = false;

function startRefineProgress() {
  refineComplete = false;
  const refineProgressFill = document.getElementById('refine-progress-fill');
  const refineProgressFillBar = document.getElementById('refine-progress-fill-bar');
  
  if (refineProgressFill) refineProgressFill.style.width = '0%';
  if (refineProgressFillBar) refineProgressFillBar.style.width = '0%';
  
  const totalDuration = 180000; // 3 minutes in milliseconds
  const startTime = Date.now();
  
  // Clear any existing interval
  if (refineProgressInterval) {
    clearInterval(refineProgressInterval);
  }
  
  refineProgressInterval = setInterval(() => {
    if (refineComplete) {
      return; // Let completeRefineProgress handle completion
    }
    
    const elapsed = Date.now() - startTime;
    const progress = Math.min((elapsed / totalDuration) * 100, 95); // Cap at 95% until completion
    
    if (refineProgressFill) refineProgressFill.style.width = progress + '%';
    if (refineProgressFillBar) refineProgressFillBar.style.width = progress + '%';
    
    // If we've reached 95% and still no response, slow down the progress
    if (progress >= 95) {
      clearInterval(refineProgressInterval);
      // Start a slower interval for the final 5%
      const slowInterval = setInterval(() => {
        if (refineComplete) {
          clearInterval(slowInterval);
          return;
        }
        const currentProgress = parseFloat(refineProgressFillBar?.style.width) || 95;
        if (currentProgress < 99) {
          const newProgress = currentProgress + 0.5;
          if (refineProgressFill) refineProgressFill.style.width = newProgress + '%';
          if (refineProgressFillBar) refineProgressFillBar.style.width = newProgress + '%';
        }
      }, 5000); // Add 0.5% every 5 seconds
    }
  }, 200); // Update every 200ms for smooth animation
}

function completeRefineProgress() {
  refineComplete = true;
  
  // Clear any existing interval
  if (refineProgressInterval) {
    clearInterval(refineProgressInterval);
    refineProgressInterval = null;
  }
  
  const refineProgressFill = document.getElementById('refine-progress-fill');
  const refineProgressFillBar = document.getElementById('refine-progress-fill-bar');
  
  // Quickly complete to 100%
  const completion = setInterval(() => {
    const currentProgress = parseInt(refineProgressFill?.style.width) || 0;
    
    if (currentProgress >= 100) {
      clearInterval(completion);
      return;
    }
    
    const newProgress = Math.min(currentProgress + 15, 100);
    if (refineProgressFill) refineProgressFill.style.width = newProgress + '%';
    if (refineProgressFillBar) refineProgressFillBar.style.width = newProgress + '%';
  }, 50); // Very fast completion
}

function toggleFullscreen() {
  const previewScreen = document.getElementById('preview-screen');
  const iframe = previewScreen.querySelector('iframe');
  
  if (!iframe) return;
  
  if (!document.fullscreenElement) {
    iframe.requestFullscreen().catch(err => {
      console.error('Failed to enter fullscreen:', err);
    });
  } else {
    document.exitFullscreen();
  }
}

function publishGame() {
  if (!currentGameHtml) {
    App.showAlert('No game to publish. Please generate a game first.', 'error');
    return;
  }
  
  const title = document.getElementById('game-title-input').value.trim() || currentGameTitle;
  document.getElementById('publish-title').value = title;
  document.getElementById('publish-description').value = `AI-generated game: ${title}`;
  
  // Ensure the form is properly populated
  setTimeout(() => {
    const modal = document.getElementById('publish-modal');
    modal.style.display = 'flex';
    modal.classList.add('show');
  }, 100);
}

function closePublishModal() {
  const modal = document.getElementById('publish-modal');
  modal.style.display = 'none';
  modal.classList.remove('show');
}

// Handle publish form submission
document.getElementById('publish-form').addEventListener('submit', async function(e) {
  e.preventDefault();
  
  if (!currentGameHtml) {
    App.showAlert('No game to publish.', 'error');
    return;
  }
  
  // Set publishing state
  setPublishingState(true);
  startPublishingProgress();
  
  // Get form values directly from the input elements
  const titleInput = document.getElementById('publish-title');
  const descriptionInput = document.getElementById('publish-description');
  
  console.log('Form elements found:', { 
    titleInput: !!titleInput, 
    descriptionInput: !!descriptionInput,
    titleValue: titleInput?.value,
    descriptionValue: descriptionInput?.value
  });
  
  const title = titleInput ? titleInput.value.trim() : '';
  const description = descriptionInput ? descriptionInput.value.trim() : '';
  const html_content = currentGameHtml || '';
  
  console.log('Form data:', { title, description, html_content_length: html_content.length });
  
  // Validate required fields
  if (!title) {
    App.showAlert('Game title is required.', 'error');
    setPublishingState(false);
    return;
  }
  
  if (!description) {
    App.showAlert('Game description is required.', 'error');
    setPublishingState(false);
    return;
  }
  
  if (!html_content) {
    App.showAlert('Game content is required.', 'error');
    setPublishingState(false);
    return;
  }
  
  const publishData = {
    title: title,
    description: description,
    html_content: html_content
  };
  
  try {
    const response = await fetch('/api/publish-game', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(publishData)
    });
    
    const data = await response.json();
    
    if (data.success) {
      completePublishingProgress();
      App.showAlert('Game published successfully to the community!', 'success');
      closePublishModal();
      
      // Optionally redirect to games page
      setTimeout(() => {
        window.location.href = '/games';
      }, 2000);
    } else {
      completePublishingProgress();
      App.showAlert(data.error || 'Failed to publish game.', 'error');
    }
  } catch (error) {
    console.error('Publish error:', error);
    completePublishingProgress();
    App.showAlert('Failed to publish game. Please try again.', 'error');
  } finally {
    setPublishingState(false);
  }
});

// Publishing State Functions
let publishingProgressInterval = null;
let publishingComplete = false;

function setPublishingState(publishing) {
  const publishBtn = document.getElementById('publish-submit-btn');
  const publishText = document.getElementById('publish-text');
  const publishProgress = document.getElementById('publish-progress');
  const cancelBtn = document.getElementById('publish-cancel-btn');
  const form = document.getElementById('publish-form');
  
  console.log('Setting publishing state:', publishing);
  console.log('Elements found:', { publishBtn: !!publishBtn, publishText: !!publishText, publishProgress: !!publishProgress });
  
  if (publishing) {
    publishText.style.display = 'none';
    publishProgress.style.display = 'flex';
    publishBtn.disabled = true;
    cancelBtn.disabled = true;
    form.querySelectorAll('input, textarea').forEach(input => input.disabled = true);
    console.log('Publishing state set to true - progress should be visible');
  } else {
    publishText.style.display = 'inline';
    publishProgress.style.display = 'none';
    publishBtn.disabled = false;
    cancelBtn.disabled = false;
    form.querySelectorAll('input, textarea').forEach(input => input.disabled = false);
    // Reset progress bar
    const publishProgressFill = document.getElementById('publish-progress-fill');
    if (publishProgressFill) {
      publishProgressFill.style.width = '0%';
    }
    console.log('Publishing state set to false - progress should be hidden');
  }
}

function startPublishingProgress() {
  publishingComplete = false;
  const publishProgressFill = document.getElementById('publish-progress-fill');
  
  console.log('Starting publishing progress, fill element:', !!publishProgressFill);
  
  if (publishProgressFill) {
    publishProgressFill.style.width = '0%';
    console.log('Progress fill reset to 0%');
  }
  
  const totalDuration = 45000; // 45 seconds for 3 attempts with 15s max wait
  const startTime = Date.now();
  
  // Clear any existing interval
  if (publishingProgressInterval) {
    clearInterval(publishingProgressInterval);
  }
  
  publishingProgressInterval = setInterval(() => {
    if (publishingComplete) {
      return; // Let completePublishingProgress handle completion
    }
    
    const elapsed = Date.now() - startTime;
    const progress = Math.min((elapsed / totalDuration) * 100, 95); // Cap at 95% until completion
    
    if (publishProgressFill) publishProgressFill.style.width = progress + '%';
    
    // If we've reached 95% and still no response, slow down the progress
    if (progress >= 95) {
      clearInterval(publishingProgressInterval);
      // Start a slower interval for the final 5%
      const slowInterval = setInterval(() => {
        if (publishingComplete) {
          clearInterval(slowInterval);
          return;
        }
        const currentProgress = parseFloat(publishProgressFill?.style.width) || 95;
        if (currentProgress < 99) {
          const newProgress = currentProgress + 0.2;
          if (publishProgressFill) publishProgressFill.style.width = newProgress + '%';
        }
      }, 2000); // Add 0.2% every 2 seconds
    }
  }, 200); // Update every 200ms for smooth animation
}

function completePublishingProgress() {
  publishingComplete = true;
  
  // Clear any existing interval
  if (publishingProgressInterval) {
    clearInterval(publishingProgressInterval);
    publishingProgressInterval = null;
  }
  
  const publishProgressFill = document.getElementById('publish-progress-fill');
  
  // Quickly complete to 100%
  const completion = setInterval(() => {
    const currentProgress = parseInt(publishProgressFill?.style.width) || 0;
    
    if (currentProgress >= 100) {
      clearInterval(completion);
      return;
    }
    
    const newProgress = Math.min(currentProgress + 20, 100);
    if (publishProgressFill) publishProgressFill.style.width = newProgress + '%';
  }, 50); // Very fast completion
}

// Close modal when clicking outside
document.getElementById('publish-modal').addEventListener('click', function(e) {
  if (e.target === this) {
    closePublishModal();
  }
});

// Test function for debugging progress bar
function testPublishingProgress() {
  console.log('Testing publishing progress...');
  setPublishingState(true);
  startPublishingProgress();
  
  // Test progress for 3 seconds
  setTimeout(() => {
    console.log('Test complete, hiding progress');
    setPublishingState(false);
  }, 3000);
}
</script>

<style>
.game-creator-container {
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: 24px;
  max-width: 1400px;
  margin: 0 auto;
  min-height: 600px;
}

.preview-panel {
  background: var(--card);
  border: 2px solid var(--line);
  border-radius: 12px;
  overflow: hidden;
}

.preview-header {
  background: var(--bg);
  border-bottom: 2px solid var(--line);
  padding: 16px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.preview-header h2 {
  color: var(--cyber);
  margin: 0;
  font-size: 16px;
  font-weight: 700;
}

.preview-controls {
  display: flex;
  gap: 12px;
}

.preview-screen {
  height: 500px;
  background: var(--bg);
  position: relative;
  overflow: hidden;
}

.preview-placeholder {
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, var(--bg) 0%, rgba(0, 255, 255, 0.05) 100%);
}

.placeholder-content {
  text-align: center;
  color: var(--muted);
}

.placeholder-icon {
  font-size: 48px;
  margin-bottom: 16px;
  opacity: 0.5;
}

.placeholder-content h3 {
  color: var(--text);
  margin-bottom: 8px;
}

.prompt-panel {
  background: var(--card);
  border: 2px solid var(--line);
  border-radius: 12px;
  padding: 24px;
  height: fit-content;
}

.prompt-header h3 {
  color: var(--cyber);
  margin: 0 0 20px 0;
  font-size: 16px;
  font-weight: 700;
}

.prompt-textarea {
  min-height: 120px;
  max-height: 200px;
  resize: vertical;
  font-family: var(--font-mono);
  line-height: 1.5;
}

.form-actions {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 16px;
}

.game-info {
  margin-top: 24px;
  padding-top: 24px;
  border-top: 1px solid var(--line);
}

.game-title-section {
  margin-bottom: 16px;
}

.game-stats {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.stat-item {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
}

.stat-label {
  color: var(--muted);
  font-weight: 600;
}

.stat-value {
  color: var(--cyber);
  font-weight: 700;
}

/* Modal Styles */
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  align-items: center;
  justify-content: center;
}

.modal.show {
  display: flex !important;
}

.modal-content {
  background: var(--card);
  border: 2px solid var(--line);
  border-radius: 12px;
  width: 90%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
}

.modal-header {
  background: var(--bg);
  border-bottom: 2px solid var(--line);
  padding: 20px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header h2 {
  color: var(--cyber);
  margin: 0;
  font-size: 18px;
}

.modal-close {
  background: none;
  border: none;
  color: var(--muted);
  font-size: 24px;
  cursor: pointer;
  padding: 0;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-close:hover {
  color: var(--text);
}

.modal-body {
  padding: 24px;
}

.modal-actions {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 24px;
  position: relative;
  z-index: 10;
}

.modal-actions .btn {
  position: relative;
  z-index: 10;
  opacity: 1 !important;
  visibility: visible !important;
  pointer-events: auto !important;
  color: var(--fg) !important;
}

.modal-actions .btn * {
  color: var(--fg) !important;
  z-index: 11;
  position: relative;
}

/* Additional button text visibility fixes */
.modal .btn span,
.modal .btn,
.modal button {
  color: #e6e6ea !important;
  font-family: 'Press Start 2P', system-ui, monospace !important;
  font-size: 11px !important;
  text-shadow: none !important;
  background-color: transparent !important;
}

/* Ensure pseudo-elements don't cover text */
.modal .btn::after {
  z-index: 1 !important;
}

.modal .btn span {
  z-index: 100 !important;
  position: relative !important;
  color: #e6e6ea !important;
}

/* Responsive Design */
@media (max-width: 768px) {
  .game-creator-container {
    grid-template-columns: 1fr;
    gap: 16px;
  }
  
  .preview-screen {
    height: 300px;
  }
  
  .preview-header {
    padding: 12px 16px;
  }
  
  .preview-controls {
    flex-direction: column;
    gap: 8px;
  }
  
  .prompt-panel {
    padding: 16px;
  }
  
  .form-actions {
    gap: 8px;
  }
  
  .modal-content {
    width: 95%;
  }
  
  .modal-body {
    padding: 16px;
  }
  
  .modal-actions {
    flex-direction: column;
  }
}

/* Progress Screen Styles */
.progress-screen {
  height: 100%;
  background: linear-gradient(135deg, var(--bg) 0%, rgba(0, 255, 255, 0.05) 100%);
  display: flex;
  align-items: flex-start;
  justify-content: center;
  padding: 20px;
  overflow-y: auto;
}

.progress-content {
  text-align: center;
  max-width: 380px;
  width: 100%;
  margin-top: 20px;
}

.progress-header h3 {
  color: var(--cyber);
  margin: 0 0 8px 0;
  font-size: 16px;
}

.progress-header p {
  color: var(--muted);
  margin: 0 0 24px 0;
  font-size: 11px;
}

.progress-bar-container {
  margin-bottom: 24px;
  position: relative;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: var(--line);
  border: 2px solid var(--line);
  position: relative;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #00ff88, #00cc66);
  width: 0%;
  transition: width 0.3s ease;
  position: relative;
}

.progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  width: 20px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3));
  animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.progress-percentage {
  position: absolute;
  top: -24px;
  right: 0;
  color: var(--cyber);
  font-size: 10px;
  font-weight: 700;
}

.progress-stages {
  display: flex;
  flex-direction: column;
  gap: 4px;
  text-align: left;
  max-height: 280px;
  overflow-y: auto;
}

.stage {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 10px;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid var(--line);
  transition: all 0.3s ease;
  min-height: 32px;
}

.stage.active {
  background: rgba(0, 255, 255, 0.1);
  border-color: var(--cyber);
}

.stage.completed {
  background: rgba(0, 255, 136, 0.1);
  border-color: #00ff88;
}

.stage-icon {
  font-size: 12px;
  width: 16px;
  text-align: center;
}

.stage-text {
  flex: 1;
  color: var(--text);
  font-size: 11px;
}

.stage-check {
  font-size: 12px;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.stage.completed .stage-check {
  opacity: 1;
}

.stage.completed .stage-icon {
  opacity: 0.3;
}

/* Button Progress Bar Styles */
.btn-progress {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(180deg, #121525, #0e1120);
  overflow: hidden;
  border-radius: 4px;
}

.btn-progress-fill {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 0%;
  background: linear-gradient(90deg, #00ff88, #00cc66);
  transition: width 0.3s ease;
  opacity: 0.8;
  border-radius: 4px;
}

.btn-progress-text {
  position: relative;
  z-index: 2;
  color: #ffffff;
  font-family: 'Press Start 2P', system-ui, monospace;
  font-size: 11px;
  text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
}

/* Refine Progress Bar Styles */
.refine-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.refine-container .btn {
  width: 100%;
}

.refine-progress-bar {
  width: 100%;
  height: 4px;
  background: var(--line);
  border: 1px solid var(--line);
  overflow: hidden;
  border-radius: 0;
}

.refine-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #00ff88, #00cc66);
  width: 0%;
  transition: width 0.3s ease;
  position: relative;
}

.refine-progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  width: 10px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3));
  animation: shimmer 1.5s infinite;
}

/* Loading animation for refine button (keep existing) */
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

#refine-loading {
  animation: spin 1s linear infinite;
}

/* Credits Display Styles */
.credits-display {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 20px;
  padding: 12px 20px;
  background: linear-gradient(135deg, var(--card), var(--grid));
  border: 2px solid var(--cyber);
  border-radius: 8px;
  display: inline-flex;
  font-size: 16px;
  font-weight: 600;
  color: var(--text);
  box-shadow: 0 4px 15px rgba(0, 255, 255, 0.1);
}

.credits-icon {
  font-size: 20px;
  animation: pulse 2s infinite;
}

.credits-text {
  color: var(--cyber);
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.1);
  }
}

/* Model Cost Display */
.model-cost {
  background: rgba(0, 255, 255, 0.1);
  border: 1px solid var(--cyber);
  border-radius: 4px;
  padding: 4px 8px;
  margin-top: 6px;
  text-align: center;
}

/* Disabled button styles */
.btn:disabled {
  opacity: 0.5 !important;
  cursor: not-allowed !important;
  pointer-events: none;
}

.btn:disabled:hover {
  transform: none !important;
  box-shadow: none !important;
}

/* Insufficient credits warning */
.model-cost.insufficient {
  color: #ff6b6b !important;
  border-color: #ff6b6b !important;
  background-color: rgba(255, 107, 107, 0.1) !important;
}

/* Responsive credits display */
@media (max-width: 768px) {
  .credits-display {
    font-size: 14px;
    padding: 10px 16px;
  }
}
</style>
{% endblock %}