{% extends "base.html" %}

{% block title %}Edit Game - GlitchPeachAI{% endblock %}

{% block content %}
<main>
  <section class="hero">
    <div class="kicker"><span class="dot"></span>EDIT â€¢ REFINE â€¢ UPDATE</div>
    <h1>EDIT YOUR GAME</h1>
    <p class="sub">Refine and improve your published game</p>
    <div class="credits-display">
      <span class="credits-icon">ðŸª™</span>
      <span class="credits-text">Balance: <strong>{{ user_credits }}</strong> Credits</span>
    </div>
  </section>

  <section class="section">
    <div class="game-creator-container">
      <!-- Game Preview Panel -->
      <div class="preview-panel">
        <div class="preview-header">
          <h2>GAME PREVIEW</h2>
          <div class="preview-controls">
            <button id="fullscreen-btn" class="btn btn-ghost" onclick="toggleFullscreen()">
              <span>â›¶ FULLSCREEN</span>
            </button>
            <button id="update-btn" class="btn btn-cta" onclick="updateGame()">
              <span>ðŸ’¾ UPDATE GAME</span>
            </button>
          </div>
        </div>
        
        <div class="preview-screen" id="preview-screen">
          <div class="preview-placeholder">
            <div class="placeholder-content">
              <div class="placeholder-icon">ðŸŽ®</div>
              <h3>Loading your game...</h3>
              <p>Please wait while we load your game content</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Game Info Panel -->
      <div class="prompt-panel">
        <div class="prompt-header">
          <h3>GAME DETAILS</h3>
        </div>
        
        <div class="game-info">
          <div class="game-title-section">
            <label class="form-label" for="game-title-input">GAME TITLE</label>
            <input class="form-input" type="text" id="game-title-input" value="{{ game.title or '' }}" placeholder="Enter game title...">
          </div>
          
          <div class="game-description-section">
            <label class="form-label" for="game-description-input">DESCRIPTION</label>
            <textarea class="form-input" id="game-description-input" rows="3" placeholder="Describe your game...">{{ game.description or '' }}</textarea>
          </div>
          
          <div class="game-stats">
            <div class="stat-item">
              <span class="stat-label">STATUS:</span>
              <span class="stat-value">PUBLISHED</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">CREATED:</span>
              <span class="stat-value">{{ game.created_at[:10] if game.created_at else 'Unknown' }}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">LAST UPDATED:</span>
              <span class="stat-value" id="last-updated">NOW</span>
            </div>
          </div>
        </div>

        <!-- Refinement Panel -->
        <div class="refinement-panel">
          <div class="refinement-header">
            <h3>AI REFINEMENT</h3>
          </div>
          
          <div class="refinement-form">
            <div class="form-group">
              <label class="form-label" for="refinement-prompt">REFINEMENT INSTRUCTIONS</label>
              <textarea 
                class="form-input prompt-textarea" 
                id="refinement-prompt" 
                name="refinement_prompt" 
                rows="4" 
                placeholder="e.g., Add more levels, improve graphics, fix bugs, add sound effects, make it more challenging..."
              ></textarea>
            </div>

            <div class="form-group">
              <label class="form-label" for="refinement-model-select">AI MODEL</label>
              <select class="form-input" id="refinement-model-select" name="refinement_model">
                <option value="QP">Quick Prototype</option>
                <option value="PG">Polished Game</option>
                <option value="PE">Premium Experience</option>
              </select>
              <div class="model-description" style="font-size: 9px; color: var(--muted); margin-top: 4px; line-height: 1.4;">
                <div id="refinement-model-desc-QP" style="display: none;">For testing game ideas, fast drafts. Cost: {{ model_prices.QP }} credit{% if model_prices.QP != 1 %}s{% endif %}.</div>
                <div id="refinement-model-desc-PG" style="display: none;">Better balance, assets, replay value. Cost: {{ model_prices.PG }} credit{% if model_prices.PG != 1 %}s{% endif %}.</div>
                <div id="refinement-model-desc-PE" style="display: none;">Top-tier AI creativity, ready-to-share games. Cost: {{ model_prices.PE }} credit{% if model_prices.PE != 1 %}s{% endif %}.</div>
              </div>
              <div class="model-cost" id="refinement-model-cost" style="font-size: 10px; color: var(--cyber); margin-top: 6px; font-weight: 600;">
                Cost: <span id="refinement-cost-amount">{{ model_prices.PE }}</span> credit{% if model_prices.PE != 1 %}s{% endif %}
              </div>
            </div>

            <div class="form-actions">
              <button id="refine-btn" class="btn btn-ghost" onclick="refineGame()">
                <span id="refine-text">ðŸ”§ REFINE GAME</span>
                <div id="refine-progress" class="btn-progress" style="display: none;">
                  <div class="btn-progress-fill" id="refine-progress-fill"></div>
                  <span class="btn-progress-text">REFINING...</span>
                </div>
              </button>
              <div class="refine-progress-bar" id="refine-progress-bar" style="display: none;">
                <div class="refine-progress-fill" id="refine-progress-fill-bar"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
</main>

<!-- Game Update Modal -->
<div id="update-modal" class="modal" style="display: none;">
  <div class="modal-content">
    <div class="modal-header">
      <h2>UPDATE GAME</h2>
      <button class="modal-close" onclick="closeUpdateModal()">&times;</button>
    </div>
    <div class="modal-body">
      <form id="update-form">
        <div class="form-group">
          <label class="form-label" for="update-title">GAME TITLE</label>
          <input class="form-input" type="text" id="update-title" name="title" required placeholder="Enter game title">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="update-description">DESCRIPTION</label>
          <textarea class="form-input" id="update-description" name="description" rows="3" required placeholder="Describe your game..."></textarea>
        </div>
        
        <div class="modal-actions">
          <button type="button" class="btn btn-ghost" onclick="closeUpdateModal()" id="update-cancel-btn" style="display: inline-flex; visibility: visible; opacity: 1; color: #e6e6ea !important; font-size: 13px;">
            <span style="color: #e6e6ea !important; position: relative; z-index: 100;">CANCEL</span>
          </button>
          <button type="submit" class="btn btn-cta" id="update-submit-btn" style="display: inline-flex; visibility: visible; opacity: 1; color: #e6e6ea !important; font-size: 13px; position: relative;">
            <span id="update-text" style="color: #e6e6ea !important; position: relative; z-index: 100;">ðŸ’¾ UPDATE GAME</span>
            <div id="update-progress" class="btn-progress" style="display: none;">
              <div class="btn-progress-fill" id="update-progress-fill"></div>
              <span class="btn-progress-text">UPDATING...</span>
            </div>
          </button>
        </div>
      </form>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Global variables
let currentGameHtml = '';
let currentGameId = '{{ game.id }}';
let isRefining = false;
let refineProgressInterval = null;
let refineComplete = false;

// Model pricing data from server
const modelPrices = {
  'QP': {{ model_prices.QP }},
  'PG': {{ model_prices.PG }},
  'PE': {{ model_prices.PE }}
};

document.addEventListener('DOMContentLoaded', function() {
  // Load the current game HTML content
  loadGameContent();
  
  // Initialize the interface
  const refinementTextarea = document.getElementById('refinement-prompt');
  const refineBtn = document.getElementById('refine-btn');
  
  // Auto-resize textarea
  refinementTextarea.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = (this.scrollHeight) + 'px';
  });
  
  // Enable refine button when there's text and enough credits
  refinementTextarea.addEventListener('input', function() {
    const hasText = this.value.trim().length > 0;
    const selectedModel = document.getElementById('refinement-model-select').value;
    const requiredCredits = modelPrices[selectedModel];
    const currentCredits = parseInt(document.querySelector('.credits-text strong').textContent);
    const hasEnoughCredits = currentCredits >= requiredCredits;
    
    refineBtn.disabled = !hasText || !hasEnoughCredits;
  });
  
  // Model selection description and cost handler
  const refinementModelSelect = document.getElementById('refinement-model-select');
  const refinementCostAmount = document.getElementById('refinement-cost-amount');
  const refinementModelCost = document.getElementById('refinement-model-cost');
  
  refinementModelSelect.addEventListener('change', function() {
    const selectedModel = this.value;
    const cost = modelPrices[selectedModel];
    
    // Hide all descriptions
    document.querySelectorAll('[id^="refinement-model-desc-"]').forEach(desc => {
      desc.style.display = 'none';
    });
    
    // Show selected model description
    const descId = `refinement-model-desc-${selectedModel}`;
    const descElement = document.getElementById(descId);
    if (descElement) {
      descElement.style.display = 'block';
    }
    
    // Update cost display
    if (refinementCostAmount) {
      refinementCostAmount.textContent = cost;
    }
    
    // Update cost text (singular/plural)
    if (refinementModelCost) {
      const creditText = cost === 1 ? 'credit' : 'credits';
      refinementModelCost.innerHTML = `Cost: <span id="refinement-cost-amount">${cost}</span> ${creditText}`;
    }
    
    // Check if user has enough credits for this model
    checkRefinementCreditsAvailability();
  });
  
  // Initialize with first model description
  refinementModelSelect.dispatchEvent(new Event('change'));
  
  // Initialize button state
  refineBtn.disabled = true;
  
  // Check credits availability on page load
  checkRefinementCreditsAvailability();
});

function checkRefinementCreditsAvailability() {
  const selectedModel = document.getElementById('refinement-model-select').value;
  const requiredCredits = modelPrices[selectedModel];
  const currentCredits = parseInt(document.querySelector('.credits-text strong').textContent);
  const refineBtn = document.getElementById('refine-btn');
  const refinementModelCost = document.getElementById('refinement-model-cost');
  
  if (currentCredits < requiredCredits) {
    // Disable refine button and show insufficient credits warning
    refineBtn.disabled = true;
    refineBtn.style.opacity = '0.5';
    refineBtn.style.cursor = 'not-allowed';
    
    // Update cost display to show insufficient credits
    if (refinementModelCost) {
      refinementModelCost.style.color = '#ff6b6b';
      refinementModelCost.style.borderColor = '#ff6b6b';
      refinementModelCost.style.backgroundColor = 'rgba(255, 107, 107, 0.1)';
      refinementModelCost.innerHTML = `Cost: <span id="refinement-cost-amount">${requiredCredits}</span> credit${requiredCredits !== 1 ? 's' : ''} <span style="color: #ff6b6b;">(Insufficient credits!)</span>`;
    }
  } else {
    // Enable refine button and show normal cost
    refineBtn.disabled = false;
    refineBtn.style.opacity = '1';
    refineBtn.style.cursor = 'pointer';
    
    // Update cost display to show normal state
    if (refinementModelCost) {
      refinementModelCost.style.color = 'var(--cyber)';
      refinementModelCost.style.borderColor = 'var(--cyber)';
      refinementModelCost.style.backgroundColor = 'rgba(0, 255, 255, 0.1)';
      refinementModelCost.innerHTML = `Cost: <span id="refinement-cost-amount">${requiredCredits}</span> credit${requiredCredits !== 1 ? 's' : ''}`;
    }
  }
}

function updateCreditsDisplay(newCredits) {
  const creditsText = document.querySelector('.credits-text strong');
  if (creditsText) {
    creditsText.textContent = newCredits;
  }
  
  // Recheck credits availability after update
  checkRefinementCreditsAvailability();
}

async function loadGameContent() {
  try {
    const response = await fetch(`/game-content/{{ game.id }}`);
    if (response.ok) {
      const htmlContent = await response.text();
      currentGameHtml = htmlContent;
      displayGamePreview(htmlContent);
    } else {
      console.error('Failed to load game content');
      App.showAlert('Failed to load game content', 'error');
    }
  } catch (error) {
    console.error('Error loading game content:', error);
    App.showAlert('Error loading game content', 'error');
  }
}

async function refineGame() {
  if (isRefining || !currentGameHtml) return;
  
  const prompt = document.getElementById('refinement-prompt').value.trim();
  const model = document.getElementById('refinement-model-select').value;
  
  if (!prompt) {
    App.showAlert('Please enter refinement instructions.', 'error');
    return;
  }
  
  // Check if user has enough credits before starting animation
  const requiredCredits = modelPrices[model];
  const currentCredits = parseInt(document.querySelector('.credits-text strong').textContent);
  
  if (currentCredits < requiredCredits) {
    App.showAlert(`Insufficient credits! You need ${requiredCredits} credits but only have ${currentCredits}.`, 'error');
    return;
  }
  
  isRefining = true;
  setRefiningState(true);
  startRefineProgress();
  
  try {
    const response = await fetch('/api/refine-game', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ 
        instruction: prompt,
        current_html: currentGameHtml,
        model: model
      })
    });
    
    const data = await response.json();
    
    if (data.success) {
      currentGameHtml = data.html;
      
      // Complete refine progress
      completeRefineProgress();
      
      // Update credits display if provided
      if (data.remaining_credits !== undefined) {
        updateCreditsDisplay(data.remaining_credits);
      }
      
      // Wait a moment then update UI
      setTimeout(() => {
        displayGamePreview(data.html);
        document.getElementById('refinement-prompt').value = '';
        document.getElementById('refinement-prompt').style.height = 'auto';
        App.showAlert(`Game refined successfully! Used ${data.credits_deducted || 0} credits.`, 'success');
      }, 800);
    } else {
      completeRefineProgress();
      setTimeout(() => {
        // Handle insufficient credits specifically
        if (data.error_type === 'insufficient_credits') {
          App.showAlert(`Insufficient credits! You need ${data.required_credits} credits but only have ${data.current_credits}.`, 'error');
        } else {
          App.showAlert(data.error || 'Failed to refine game. Please try again.', 'error');
        }
      }, 500);
    }
  } catch (error) {
    console.error('Refinement error:', error);
    completeRefineProgress();
    setTimeout(() => {
      App.showAlert('Failed to refine game. Please check your connection and try again.', 'error');
    }, 500);
  } finally {
    isRefining = false;
    setRefiningState(false);
  }
}

function displayGamePreview(html) {
  const previewScreen = document.getElementById('preview-screen');
  
  // Create iframe for game preview
  const iframe = document.createElement('iframe');
  iframe.style.width = '100%';
  iframe.style.height = '100%';
  iframe.style.border = 'none';
  iframe.style.borderRadius = '8px';
  iframe.srcdoc = html;
  
  // Clear previous content and add iframe
  previewScreen.innerHTML = '';
  previewScreen.appendChild(iframe);
}

function setRefiningState(refining) {
  const refineBtn = document.getElementById('refine-btn');
  const refineText = document.getElementById('refine-text');
  const refineProgress = document.getElementById('refine-progress');
  const refineProgressBar = document.getElementById('refine-progress-bar');
  const refinementTextarea = document.getElementById('refinement-prompt');
  
  if (refining) {
    refineText.style.display = 'none';
    refineProgress.style.display = 'flex';
    refineProgressBar.style.display = 'block';
    refineBtn.disabled = true;
    refinementTextarea.disabled = true;
  } else {
    refineText.style.display = 'inline';
    refineProgress.style.display = 'none';
    refineProgressBar.style.display = 'none';
    refineBtn.disabled = false;
    refinementTextarea.disabled = false;
    // Reset progress bars
    const refineProgressFill = document.getElementById('refine-progress-fill');
    const refineProgressFillBar = document.getElementById('refine-progress-fill-bar');
    if (refineProgressFill) refineProgressFill.style.width = '0%';
    if (refineProgressFillBar) refineProgressFillBar.style.width = '0%';
  }
}

// Refine Progress Functions
function startRefineProgress() {
  refineComplete = false;
  const refineProgressFill = document.getElementById('refine-progress-fill');
  const refineProgressFillBar = document.getElementById('refine-progress-fill-bar');
  
  if (refineProgressFill) refineProgressFill.style.width = '0%';
  if (refineProgressFillBar) refineProgressFillBar.style.width = '0%';
  
  const totalDuration = 180000; // 3 minutes in milliseconds
  const startTime = Date.now();
  
  // Clear any existing interval
  if (refineProgressInterval) {
    clearInterval(refineProgressInterval);
  }
  
  refineProgressInterval = setInterval(() => {
    if (refineComplete) {
      return; // Let completeRefineProgress handle completion
    }
    
    const elapsed = Date.now() - startTime;
    const progress = Math.min((elapsed / totalDuration) * 100, 95); // Cap at 95% until completion
    
    if (refineProgressFill) refineProgressFill.style.width = progress + '%';
    if (refineProgressFillBar) refineProgressFillBar.style.width = progress + '%';
    
    // If we've reached 95% and still no response, slow down the progress
    if (progress >= 95) {
      clearInterval(refineProgressInterval);
      // Start a slower interval for the final 5%
      const slowInterval = setInterval(() => {
        if (refineComplete) {
          clearInterval(slowInterval);
          return;
        }
        const currentProgress = parseFloat(refineProgressFillBar?.style.width) || 95;
        if (currentProgress < 99) {
          const newProgress = currentProgress + 0.5;
          if (refineProgressFill) refineProgressFill.style.width = newProgress + '%';
          if (refineProgressFillBar) refineProgressFillBar.style.width = newProgress + '%';
        }
      }, 5000); // Add 0.5% every 5 seconds
    }
  }, 200); // Update every 200ms for smooth animation
}

function completeRefineProgress() {
  refineComplete = true;
  
  // Clear any existing interval
  if (refineProgressInterval) {
    clearInterval(refineProgressInterval);
    refineProgressInterval = null;
  }
  
  const refineProgressFill = document.getElementById('refine-progress-fill');
  const refineProgressFillBar = document.getElementById('refine-progress-fill-bar');
  
  // Quickly complete to 100%
  const completion = setInterval(() => {
    const currentProgress = parseInt(refineProgressFill?.style.width) || 0;
    
    if (currentProgress >= 100) {
      clearInterval(completion);
      return;
    }
    
    const newProgress = Math.min(currentProgress + 15, 100);
    if (refineProgressFill) refineProgressFill.style.width = newProgress + '%';
    if (refineProgressFillBar) refineProgressFillBar.style.width = newProgress + '%';
  }, 50); // Very fast completion
}

function toggleFullscreen() {
  const previewScreen = document.getElementById('preview-screen');
  const iframe = previewScreen.querySelector('iframe');
  
  if (!iframe) return;
  
  if (!document.fullscreenElement) {
    iframe.requestFullscreen().catch(err => {
      console.error('Failed to enter fullscreen:', err);
    });
  } else {
    document.exitFullscreen();
  }
}

function updateGame() {
  if (!currentGameHtml) {
    App.showAlert('No game content to update.', 'error');
    return;
  }
  
  const title = document.getElementById('game-title-input').value.trim();
  const description = document.getElementById('game-description-input').value.trim();
  
  if (!title) {
    App.showAlert('Game title is required.', 'error');
    return;
  }
  
  if (!description) {
    App.showAlert('Game description is required.', 'error');
    return;
  }
  
  document.getElementById('update-title').value = title;
  document.getElementById('update-description').value = description;
  
  // Show the update modal
  setTimeout(() => {
    const modal = document.getElementById('update-modal');
    modal.style.display = 'flex';
    modal.classList.add('show');
  }, 100);
}

function closeUpdateModal() {
  const modal = document.getElementById('update-modal');
  modal.style.display = 'none';
  modal.classList.remove('show');
}

// Handle update form submission
document.getElementById('update-form').addEventListener('submit', async function(e) {
  e.preventDefault();
  
  if (!currentGameHtml) {
    App.showAlert('No game content to update.', 'error');
    return;
  }
  
  // Set updating state
  setUpdatingState(true);
  startUpdatingProgress();
  
  // Get form values
  const title = document.getElementById('update-title').value.trim();
  const description = document.getElementById('update-description').value.trim();
  
  // Validate required fields
  if (!title) {
    App.showAlert('Game title is required.', 'error');
    setUpdatingState(false);
    return;
  }
  
  if (!description) {
    App.showAlert('Game description is required.', 'error');
    setUpdatingState(false);
    return;
  }
  
  const updateData = {
    game_id: currentGameId,
    title: title,
    description: description,
    html_content: currentGameHtml
  };
  
  try {
    const response = await fetch('/api/update-game', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updateData)
    });
    
    const data = await response.json();
    
    if (data.success) {
      completeUpdatingProgress();
      App.showAlert('Game updated successfully!', 'success');
      closeUpdateModal();
      
      // Update the form fields with new values
      document.getElementById('game-title-input').value = title;
      document.getElementById('game-description-input').value = description;
      document.getElementById('last-updated').textContent = new Date().toLocaleString();
      
      // Optionally redirect to my-games page
      setTimeout(() => {
        window.location.href = '/my-games';
      }, 2000);
    } else {
      completeUpdatingProgress();
      App.showAlert(data.error || 'Failed to update game.', 'error');
    }
  } catch (error) {
    console.error('Update error:', error);
    completeUpdatingProgress();
    App.showAlert('Failed to update game. Please try again.', 'error');
  } finally {
    setUpdatingState(false);
  }
});

// Updating State Functions
let updatingProgressInterval = null;
let updatingComplete = false;

function setUpdatingState(updating) {
  const updateBtn = document.getElementById('update-submit-btn');
  const updateText = document.getElementById('update-text');
  const updateProgress = document.getElementById('update-progress');
  const cancelBtn = document.getElementById('update-cancel-btn');
  const form = document.getElementById('update-form');
  
  if (updating) {
    updateText.style.display = 'none';
    updateProgress.style.display = 'flex';
    updateBtn.disabled = true;
    cancelBtn.disabled = true;
    form.querySelectorAll('input, textarea').forEach(input => input.disabled = true);
  } else {
    updateText.style.display = 'inline';
    updateProgress.style.display = 'none';
    updateBtn.disabled = false;
    cancelBtn.disabled = false;
    form.querySelectorAll('input, textarea').forEach(input => input.disabled = false);
    // Reset progress bar
    const updateProgressFill = document.getElementById('update-progress-fill');
    if (updateProgressFill) {
      updateProgressFill.style.width = '0%';
    }
  }
}

function startUpdatingProgress() {
  updatingComplete = false;
  const updateProgressFill = document.getElementById('update-progress-fill');
  
  if (updateProgressFill) {
    updateProgressFill.style.width = '0%';
  }
  
  const totalDuration = 45000; // 45 seconds for 3 attempts with 15s max wait
  const startTime = Date.now();
  
  // Clear any existing interval
  if (updatingProgressInterval) {
    clearInterval(updatingProgressInterval);
  }
  
  updatingProgressInterval = setInterval(() => {
    if (updatingComplete) {
      return; // Let completeUpdatingProgress handle completion
    }
    
    const elapsed = Date.now() - startTime;
    const progress = Math.min((elapsed / totalDuration) * 100, 95); // Cap at 95% until completion
    
    if (updateProgressFill) updateProgressFill.style.width = progress + '%';
    
    // If we've reached 95% and still no response, slow down the progress
    if (progress >= 95) {
      clearInterval(updatingProgressInterval);
      // Start a slower interval for the final 5%
      const slowInterval = setInterval(() => {
        if (updatingComplete) {
          clearInterval(slowInterval);
          return;
        }
        const currentProgress = parseFloat(updateProgressFill?.style.width) || 95;
        if (currentProgress < 99) {
          const newProgress = currentProgress + 0.2;
          if (updateProgressFill) updateProgressFill.style.width = newProgress + '%';
        }
      }, 2000); // Add 0.2% every 2 seconds
    }
  }, 200); // Update every 200ms for smooth animation
}

function completeUpdatingProgress() {
  updatingComplete = true;
  
  // Clear any existing interval
  if (updatingProgressInterval) {
    clearInterval(updatingProgressInterval);
    updatingProgressInterval = null;
  }
  
  const updateProgressFill = document.getElementById('update-progress-fill');
  
  // Quickly complete to 100%
  const completion = setInterval(() => {
    const currentProgress = parseInt(updateProgressFill?.style.width) || 0;
    
    if (currentProgress >= 100) {
      clearInterval(completion);
      return;
    }
    
    const newProgress = Math.min(currentProgress + 20, 100);
    if (updateProgressFill) updateProgressFill.style.width = newProgress + '%';
  }, 50); // Very fast completion
}

// Close modal when clicking outside
document.getElementById('update-modal').addEventListener('click', function(e) {
  if (e.target === this) {
    closeUpdateModal();
  }
});
</script>

<style>
.game-creator-container {
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: 24px;
  max-width: 1400px;
  margin: 0 auto;
  min-height: 600px;
}

.preview-panel {
  background: var(--card);
  border: 2px solid var(--line);
  border-radius: 12px;
  overflow: hidden;
}

.preview-header {
  background: var(--bg);
  border-bottom: 2px solid var(--line);
  padding: 16px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.preview-header h2 {
  color: var(--cyber);
  margin: 0;
  font-size: 16px;
  font-weight: 700;
}

.preview-controls {
  display: flex;
  gap: 12px;
}

.preview-screen {
  height: 500px;
  background: var(--bg);
  position: relative;
  overflow: hidden;
}

.preview-placeholder {
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, var(--bg) 0%, rgba(0, 255, 255, 0.05) 100%);
}

.placeholder-content {
  text-align: center;
  color: var(--muted);
}

.placeholder-icon {
  font-size: 48px;
  margin-bottom: 16px;
  opacity: 0.5;
}

.placeholder-content h3 {
  color: var(--text);
  margin-bottom: 8px;
}

.prompt-panel {
  background: var(--card);
  border: 2px solid var(--line);
  border-radius: 12px;
  padding: 24px;
  height: fit-content;
}

.prompt-header h3 {
  color: var(--cyber);
  margin: 0 0 20px 0;
  font-size: 16px;
  font-weight: 700;
}

.game-info {
  margin-bottom: 24px;
  padding-bottom: 24px;
  border-bottom: 1px solid var(--line);
}

.game-title-section, .game-description-section {
  margin-bottom: 16px;
}

.game-stats {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.stat-item {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
}

.stat-label {
  color: var(--muted);
  font-weight: 600;
}

.stat-value {
  color: var(--cyber);
  font-weight: 700;
}

.refinement-panel {
  margin-top: 24px;
}

.refinement-header h3 {
  color: var(--cyber);
  margin: 0 0 16px 0;
  font-size: 16px;
  font-weight: 700;
}

.prompt-textarea {
  min-height: 120px;
  max-height: 200px;
  resize: vertical;
  font-family: var(--font-mono);
  line-height: 1.5;
}

.form-actions {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 16px;
}

/* Modal Styles */
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  align-items: center;
  justify-content: center;
}

.modal.show {
  display: flex !important;
}

.modal-content {
  background: var(--card);
  border: 2px solid var(--line);
  border-radius: 12px;
  width: 90%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
}

.modal-header {
  background: var(--bg);
  border-bottom: 2px solid var(--line);
  padding: 20px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header h2 {
  color: var(--cyber);
  margin: 0;
  font-size: 18px;
}

.modal-close {
  background: none;
  border: none;
  color: var(--muted);
  font-size: 24px;
  cursor: pointer;
  padding: 0;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-close:hover {
  color: var(--text);
}

.modal-body {
  padding: 24px;
}

.modal-actions {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 24px;
  position: relative;
  z-index: 10;
}

.modal-actions .btn {
  position: relative;
  z-index: 10;
  opacity: 1 !important;
  visibility: visible !important;
  pointer-events: auto !important;
  color: var(--fg) !important;
}

.modal-actions .btn * {
  color: var(--fg) !important;
  z-index: 11;
  position: relative;
}

/* Additional button text visibility fixes */
.modal .btn span,
.modal .btn,
.modal button {
  color: #e6e6ea !important;
  font-family: 'Press Start 2P', system-ui, monospace !important;
  font-size: 11px !important;
  text-shadow: none !important;
  background-color: transparent !important;
}

/* Ensure pseudo-elements don't cover text */
.modal .btn::after {
  z-index: 1 !important;
}

.modal .btn span {
  z-index: 100 !important;
  position: relative !important;
  color: #e6e6ea !important;
}

/* Button Progress Bar Styles */
.btn-progress {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(180deg, #121525, #0e1120);
  overflow: hidden;
  border-radius: 30px;
}

.btn-progress-fill {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 0%;
  background: linear-gradient(90deg, #00ff88, #00cc66);
  transition: width 0.3s ease;
  opacity: 0.8;
  border-radius: 30px;
}

.btn-progress-text {
  position: relative;
  z-index: 2;
  color: #ffffff;
  font-family: 'Press Start 2P', system-ui, monospace;
  font-size: 11px;
  text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
}

/* Refine Progress Bar Styles */
.refine-progress-bar {
  width: 100%;
  height: 4px;
  background: var(--line);
  border: 1px solid var(--line);
  overflow: hidden;
  border-radius: 0;
}

.refine-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #00ff88, #00cc66);
  width: 0%;
  transition: width 0.3s ease;
  position: relative;
}

.refine-progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  width: 10px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3));
  animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

/* Credits Display Styles */
.credits-display {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 20px;
  padding: 12px 20px;
  background: linear-gradient(135deg, var(--card), var(--grid));
  border: 2px solid var(--cyber);
  border-radius: 8px;
  display: inline-flex;
  font-size: 16px;
  font-weight: 600;
  color: var(--text);
  box-shadow: 0 4px 15px rgba(0, 255, 255, 0.1);
}

.credits-icon {
  font-size: 20px;
  animation: pulse 2s infinite;
}

.credits-text {
  color: var(--cyber);
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.1);
  }
}

/* Model Cost Display */
.model-cost {
  background: rgba(0, 255, 255, 0.1);
  border: 1px solid var(--cyber);
  border-radius: 30px;
  padding: 4px 8px;
  margin-top: 6px;
  text-align: center;
}

/* Disabled button styles */
.btn:disabled {
  opacity: 0.5 !important;
  cursor: not-allowed !important;
  pointer-events: none;
}

.btn:disabled:hover {
  transform: none !important;
  box-shadow: none !important;
}

/* Insufficient credits warning */
.model-cost.insufficient {
  color: #ff6b6b !important;
  border-color: #ff6b6b !important;
  background-color: rgba(255, 107, 107, 0.1) !important;
}

/* Responsive Design */
@media (max-width: 768px) {
  .game-creator-container {
    grid-template-columns: 1fr;
    gap: 16px;
  }
  
  .preview-screen {
    height: 300px;
  }
  
  .preview-header {
    padding: 12px 16px;
  }
  
  .preview-controls {
    flex-direction: column;
    gap: 8px;
  }
  
  .prompt-panel {
    padding: 16px;
  }
  
  .form-actions {
    gap: 8px;
  }
  
  .modal-content {
    width: 95%;
  }
  
  .modal-body {
    padding: 16px;
  }
  
  .modal-actions {
    flex-direction: column;
  }
}
</style>
{% endblock %}
